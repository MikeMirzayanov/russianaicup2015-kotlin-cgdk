package model

/**
 * Этот класс описывает игровой мир. Содержит также описания всех игроков и игровых объектов (<<юнитов>>).
 */
class World(
        /**
         * @return Возвращает номер текущего тика.
         */
        val tick: Int,
        /**
         * @return Возвращает базовую длительность игры в тиках.
         * Реальная длительность может отличаться от этого значения в меньшую сторону.
         * Поле может быть определено как `game.initialFreezeDurationTicks + game.lapCount * game.lapTickCount`.
         * Значение поля не меняется в процессе игры. Эквивалентно `game.tickCount`.
         */
        val tickCount: Int,
        /**
         * @return Возвращает номер последнего тика игры.
         * Сразу после старта содержит значение `tickCount - 1`.
         * В момент завершения трассы любым из кодемобилей получает значение
         * `min(tickCount - 1, tick + max(floor(game.burningTimeDurationFactor * game.lapTickCount), 1))`.
         * Таким образом, кодемобиль, отставший от идущего впереди более, чем на `game.burningTimeDurationFactor`
         * кругов, рискует не успеть вообще добраться до финиша.
         *
         * Игра может закончиться раньше, чем наступит `lastTickIndex`, если для каждого игрока выполняется одно
         * из двух условий: стратегия игрока <<упала>>, либо все его кодемобили финишировали.
         */
        val lastTickIndex: Int,
        /**
         * @return Возвращает ширину мира в тайлах.
         */
        val width: Int,
        /**
         * @return Возвращает высоту мира в тайлах.
         */
        val height: Int,
        players: Array<Player>,
        cars: Array<Car>,
        projectiles: Array<Projectile>,
        bonuses: Array<Bonus>,
        oilSlicks: Array<OilSlick>,
        /**
         * @return Возвращает краткое уникальное название трассы.
         */
        val mapName: String,
        tilesXY: Array<Array<TileType>>,
        waypoints: Array<IntArray>,
        /**
         * @return Направление кодемобиля в начале игры.
         */
        val startingDirection: Direction
) {
    /**
     * @return Возвращает список игроков (в случайном порядке).
     * После каждого тика объекты, задающие игроков, пересоздаются.
     */
    val players: Array<Player> = players.copyOf()

    /**
     * @return Возвращает список кодемобилей (в случайном порядке).
     * После каждого тика объекты, задающие кодемобили, пересоздаются.
     */
    val cars: Array<Car> = cars.copyOf()

    /**
     * @return Возвращает список снарядов (в случайном порядке).
     * После каждого тика объекты, задающие снаряды, пересоздаются.
     */
    val projectiles: Array<Projectile> = projectiles.copyOf()

    /**
     * @return Возвращает список бонусов (в случайном порядке).
     * После каждого тика объекты, задающие бонусы, пересоздаются.
     */
    val bonuses: Array<Bonus> = bonuses.copyOf()

    /**
     * @return Возвращает список масляных луж (в случайном порядке).
     * После каждого тика объекты, задающие лужи, пересоздаются.
     */
    val oilSlicks: Array<OilSlick> = oilSlicks.copyOf()

    /**
     * @return Возвращает двумерный массив тайлов, где первое измерение --- это позиция X, а второе --- Y.
     * Конвертировать позицию в точные координаты можно, используя значение `game.trackTileSize`.
     */
    val tilesXY: Array<Array<TileType>> = Array(width) { i -> tilesXY[i].copyOf() }

    /**
     * @return Возвращает массив ключевых тайлов. Каждый тайл задаётся массивом длины 2,
     * где элемент с индексом `0` содержит позицию X, а элемент с индексом `1` --- позицию Y.
     * Конвертировать позицию в точные координаты можно, используя значение `game.trackTileSize`.
     * Для прохождения круга кодемобилю необходимо посещать тайлы в указанном порядке.
     * Ключевой тайл с индексом `0` является одновременно начальным тайлом трассы и конечным тайлом каждого круга.
     * Считается, что кодемобиль посетил ключевой тайл, если центр кодемобиля пересёк границу этого тайла.
     */
    val waypoints: Array<IntArray> = Array(waypoints.size) { i -> waypoints[i].copyOf() }

    /**
     * @return Возвращает вашего игрока.
     */
    val myPlayer: Player
        get() = players.first { it.isMe }
}
